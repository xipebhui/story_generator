# Tab 1: Pipelineç®¡ç†

> å‚è€ƒï¼š[global_context.md](./global_context.md) - å…¨å±€ä¸Šä¸‹æ–‡å’Œè§„èŒƒ

## 1. å‰ç«¯æ–¹æ¡ˆ

### 1.1 ç•Œé¢å¸ƒå±€
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Pipelineç®¡ç†                                    [+ åˆ›å»ºPipeline] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ” æœç´¢: [___________] [ç±»å‹â–¼] [çŠ¶æ€â–¼]                 [æœç´¢]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  Pipelineåˆ—è¡¨ï¼ˆè¡¨æ ¼ï¼‰                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ ID     â”‚ åç§°         â”‚ ç±»å‹      â”‚ä½¿ç”¨æ•°  â”‚ çŠ¶æ€   â”‚ æ“ä½œ    â”‚â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚
â”‚  â”‚story_v3â”‚YouTubeæ•…äº‹   â”‚content   â”‚5ä¸ªé…ç½® â”‚ âœ…å¯ç”¨ â”‚æŸ¥çœ‹ ç¼–è¾‘â”‚â”‚
â”‚  â”‚meta_genâ”‚å…ƒæ•°æ®ç”Ÿæˆ    â”‚metadata  â”‚3ä¸ªé…ç½® â”‚ âœ…å¯ç”¨ â”‚æŸ¥çœ‹ ç¼–è¾‘â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ç»„ä»¶ç»“æ„
```tsx
// components/AutoPublish/PipelineManager.tsx
import React, { useState, useEffect } from 'react';
import { 
  Card, Table, Button, Modal, Form, Input, Select, 
  Tag, Space, Drawer, Descriptions, message, Popconfirm 
} from 'antd';
import { PlusOutlined, EditOutlined, DeleteOutlined, EyeOutlined } from '@ant-design/icons';

interface Pipeline {
  pipeline_id: string;
  pipeline_name: string;
  pipeline_type: string;
  pipeline_class: string;
  config_schema: ConfigSchema;
  supported_platforms: string[];
  version: string;
  status: 'active' | 'inactive' | 'testing';
  metadata?: any;
  created_at: string;
  updated_at: string;
  usage_count?: number;  // å…³è”çš„PublishConfigæ•°é‡
}

interface ConfigSchema {
  type: 'object';
  properties: {
    [key: string]: Parameter;
  };
  required?: string[];
}

interface Parameter {
  type: 'string' | 'integer' | 'number' | 'boolean' | 'array' | 'object';
  description?: string;
  default?: any;
  minimum?: number;
  maximum?: number;
  enum?: any[];
  items?: Parameter;  // for array type
  properties?: { [key: string]: Parameter };  // for object type
}

interface PublishConfigSummary {
  config_id: string;
  config_name: string;
  group_name: string;
  is_active: boolean;
  task_count: number;
}
```

### 1.3 Pipelineåˆ›å»º/ç¼–è¾‘è¡¨å•

#### 1.3.1 åŸºæœ¬ä¿¡æ¯éƒ¨åˆ†
```tsx
<Form.Item name="pipeline_id" label="Pipeline ID" 
  rules={[{ required: true, pattern: /^[a-z0-9_]+$/ }]}>
  <Input placeholder="ä¾‹å¦‚: youtube_story_v3" disabled={isEdit} />
</Form.Item>

<Form.Item name="pipeline_name" label="Pipelineåç§°" 
  rules={[{ required: true }]}>
  <Input placeholder="ä¾‹å¦‚: YouTubeæ•…äº‹ç”ŸæˆV3" />
</Form.Item>

<Form.Item name="pipeline_type" label="ç±»å‹" 
  rules={[{ required: true }]}>
  <Select>
    <Option value="content_generation">å†…å®¹ç”Ÿæˆ</Option>
    <Option value="metadata">å…ƒæ•°æ®å¤„ç†</Option>
    <Option value="content_processing">å†…å®¹å¤„ç†</Option>
    <Option value="analysis">åˆ†æ</Option>
  </Select>
</Form.Item>

<Form.Item name="pipeline_class" label="æ‰§è¡Œç±»" 
  rules={[{ required: true }]}>
  <Input placeholder="ä¾‹å¦‚: story_pipeline_v3_runner.StoryPipelineV3Runner" />
</Form.Item>

<Form.Item name="supported_platforms" label="æ”¯æŒå¹³å°">
  <Select mode="multiple">
    <Option value="youtube">YouTube</Option>
    <Option value="bilibili">Bilibili</Option>
    <Option value="douyin">æŠ–éŸ³</Option>
    <Option value="tiktok">TikTok</Option>
  </Select>
</Form.Item>
```

#### 1.3.2 å‚æ•°é…ç½®éƒ¨åˆ†ï¼ˆåŠ¨æ€è¡¨å•ï¼‰
```tsx
interface ParameterConfig {
  name: string;
  type: string;
  required: boolean;
  description?: string;
  default?: any;
  minimum?: number;
  maximum?: number;
}

const ParameterForm: React.FC = () => {
  const [parameters, setParameters] = useState<ParameterConfig[]>([]);
  
  const addParameter = () => {
    setParameters([...parameters, {
      name: '',
      type: 'string',
      required: false
    }]);
  };
  
  const removeParameter = (index: number) => {
    setParameters(parameters.filter((_, i) => i !== index));
  };
  
  return (
    <>
      {parameters.map((param, index) => (
        <Card key={index} size="small" style={{ marginBottom: 16 }}>
          <Row gutter={16}>
            <Col span={6}>
              <Input placeholder="å‚æ•°å" value={param.name} 
                onChange={e => updateParameter(index, 'name', e.target.value)} />
            </Col>
            <Col span={4}>
              <Select value={param.type} 
                onChange={v => updateParameter(index, 'type', v)}>
                <Option value="string">å­—ç¬¦ä¸²</Option>
                <Option value="integer">æ•´æ•°</Option>
                <Option value="number">æ•°å­—</Option>
                <Option value="boolean">å¸ƒå°”</Option>
                <Option value="array">æ•°ç»„</Option>
                <Option value="object">å¯¹è±¡</Option>
              </Select>
            </Col>
            <Col span={3}>
              <Checkbox checked={param.required}
                onChange={e => updateParameter(index, 'required', e.target.checked)}>
                å¿…å¡«
              </Checkbox>
            </Col>
            <Col span={8}>
              <Input placeholder="æè¿°" value={param.description}
                onChange={e => updateParameter(index, 'description', e.target.value)} />
            </Col>
            <Col span={2}>
              <Button danger icon={<DeleteOutlined />} 
                onClick={() => removeParameter(index)} />
            </Col>
          </Row>
          
          {/* æ ¹æ®ç±»å‹æ˜¾ç¤ºé¢å¤–é…ç½® */}
          {param.type === 'integer' || param.type === 'number' ? (
            <Row gutter={16} style={{ marginTop: 8 }}>
              <Col span={6}>
                <InputNumber placeholder="æœ€å°å€¼" value={param.minimum}
                  onChange={v => updateParameter(index, 'minimum', v)} />
              </Col>
              <Col span={6}>
                <InputNumber placeholder="æœ€å¤§å€¼" value={param.maximum}
                  onChange={v => updateParameter(index, 'maximum', v)} />
              </Col>
              <Col span={6}>
                <InputNumber placeholder="é»˜è®¤å€¼" value={param.default}
                  onChange={v => updateParameter(index, 'default', v)} />
              </Col>
            </Row>
          ) : null}
        </Card>
      ))}
      
      <Button type="dashed" icon={<PlusOutlined />} onClick={addParameter} block>
        æ·»åŠ å‚æ•°
      </Button>
    </>
  );
};
```

### 1.4 Pipelineè¯¦æƒ…æŠ½å±‰
```tsx
const PipelineDetail: React.FC<{ pipeline: Pipeline }> = ({ pipeline }) => {
  const [configs, setConfigs] = useState<PublishConfigSummary[]>([]);
  
  return (
    <Drawer title="Pipelineè¯¦æƒ…" width={800} visible={visible} onClose={onClose}>
      <Descriptions title="åŸºæœ¬ä¿¡æ¯" bordered column={2}>
        <Descriptions.Item label="ID">{pipeline.pipeline_id}</Descriptions.Item>
        <Descriptions.Item label="åç§°">{pipeline.pipeline_name}</Descriptions.Item>
        <Descriptions.Item label="ç±»å‹">{pipeline.pipeline_type}</Descriptions.Item>
        <Descriptions.Item label="ç‰ˆæœ¬">{pipeline.version}</Descriptions.Item>
        <Descriptions.Item label="æ‰§è¡Œç±»" span={2}>
          {pipeline.pipeline_class}
        </Descriptions.Item>
        <Descriptions.Item label="æ”¯æŒå¹³å°" span={2}>
          {pipeline.supported_platforms.map(p => (
            <Tag key={p}>{p}</Tag>
          ))}
        </Descriptions.Item>
        <Descriptions.Item label="çŠ¶æ€">
          <Tag color={pipeline.status === 'active' ? 'green' : 'default'}>
            {pipeline.status}
          </Tag>
        </Descriptions.Item>
        <Descriptions.Item label="åˆ›å»ºæ—¶é—´">{pipeline.created_at}</Descriptions.Item>
      </Descriptions>
      
      <Divider />
      
      <Card title="å‚æ•°é…ç½®" size="small">
        {Object.entries(pipeline.config_schema.properties).map(([key, param]) => (
          <div key={key} style={{ marginBottom: 8 }}>
            <Text strong>{key}</Text>
            <Tag color={pipeline.config_schema.required?.includes(key) ? 'red' : 'default'}>
              {pipeline.config_schema.required?.includes(key) ? 'å¿…å¡«' : 'å¯é€‰'}
            </Tag>
            <Tag>{param.type}</Tag>
            {param.description && <Text type="secondary"> - {param.description}</Text>}
            {param.default !== undefined && (
              <Text type="secondary"> (é»˜è®¤: {JSON.stringify(param.default)})</Text>
            )}
          </div>
        ))}
      </Card>
      
      <Divider />
      
      <Card title={`å…³è”çš„å‘å¸ƒé…ç½® (${configs.length})`} size="small">
        <List
          dataSource={configs}
          renderItem={config => (
            <List.Item 
              actions={[
                <Button type="link" onClick={() => navigateToConfig(config.config_id)}>
                  æŸ¥çœ‹
                </Button>
              ]}>
              <List.Item.Meta
                title={config.config_name}
                description={`${config.group_name} - ${config.task_count}æ¬¡æ‰§è¡Œ`}
              />
              <Tag color={config.is_active ? 'green' : 'default'}>
                {config.is_active ? 'å¯ç”¨' : 'åœç”¨'}
              </Tag>
            </List.Item>
          )}
        />
      </Card>
    </Drawer>
  );
};
```

## 2. éœ€è¦çš„æ¥å£

### 2.1 å¤ç”¨ç°æœ‰æ¥å£
```http
GET /api/auto-publish/pipelines
POST /api/auto-publish/pipelines/register
```

### 2.2 æ–°å¢æ¥å£

#### 2.2.1 è·å–Pipelineè¯¦æƒ…
```http
GET /api/auto-publish/pipelines/{pipeline_id}

å“åº”:
{
  "pipeline_id": "youtube_story_v3",
  "pipeline_name": "YouTubeæ•…äº‹ç”ŸæˆV3",
  "pipeline_type": "content_generation",
  "pipeline_class": "story_pipeline_v3_runner.StoryPipelineV3Runner",
  "config_schema": {
    "type": "object",
    "properties": {
      "video_id": {
        "type": "string",
        "description": "YouTubeè§†é¢‘ID"
      },
      "image_library": {
        "type": "string",
        "description": "å›¾åº“åç§°",
        "default": "default",
        "enum": ["default", "nature", "cartoon", "abstract"]
      },
      "image_duration": {
        "type": "integer",
        "description": "å•ä¸ªå›¾ç‰‡æŒç»­æ—¶é•¿(ç§’)",
        "default": 5,
        "minimum": 3,
        "maximum": 10
      }
    },
    "required": ["video_id"]
  },
  "supported_platforms": ["youtube", "bilibili"],
  "version": "3.0.0",
  "status": "active",
  "metadata": {},
  "created_at": "2024-12-25T10:00:00Z",
  "updated_at": "2024-12-25T10:00:00Z",
  "usage_count": 5
}
```

#### 2.2.2 æ›´æ–°Pipeline
```http
PUT /api/auto-publish/pipelines/{pipeline_id}

è¯·æ±‚ä½“: åŒåˆ›å»ºï¼Œä½†pipeline_idä¸å¯ä¿®æ”¹

å“åº”: æ›´æ–°åçš„Pipelineå¯¹è±¡
```

#### 2.2.3 åˆ é™¤Pipeline
```http
DELETE /api/auto-publish/pipelines/{pipeline_id}

å“åº”:
{
  "success": true,
  "message": "Pipeline deleted successfully"
}
```

#### 2.2.4 è·å–Pipelineå…³è”çš„é…ç½®
```http
GET /api/auto-publish/pipelines/{pipeline_id}/configs

Queryå‚æ•°:
  - page: number (é»˜è®¤1)
  - page_size: number (é»˜è®¤10)

å“åº”:
{
  "configs": [
    {
      "config_id": "config_001",
      "config_name": "æ¯æ—¥æ•…äº‹å‘å¸ƒ",
      "group_id": "story_channels",
      "group_name": "æ•…äº‹é¢‘é“ç»„",
      "is_active": true,
      "task_count": 156,
      "last_execution": "2024-12-25T20:00:00Z"
    }
  ],
  "total": 5,
  "page": 1,
  "page_size": 10
}
```

## 3. åç«¯æ‰§è¡Œæµç¨‹

### 3.1 Pipelineæ³¨å†Œæµç¨‹
```python
@router.post("/pipelines/register")
async def register_pipeline(
    request: RegisterPipelineRequest,
    current_user = Depends(get_current_user)
):
    """æ³¨å†Œæ–°çš„Pipeline"""
    registry = get_pipeline_registry()
    
    # 1. éªŒè¯pipeline_idå”¯ä¸€æ€§
    existing = registry.get_pipeline(request.pipeline_id)
    if existing:
        raise HTTPException(400, "Pipeline ID already exists")
    
    # 2. éªŒè¯config_schemaæ ¼å¼
    try:
        validate_json_schema(request.config_schema)
    except Exception as e:
        raise HTTPException(400, f"Invalid config schema: {e}")
    
    # 3. éªŒè¯pipeline_classå­˜åœ¨ï¼ˆå¯é€‰ï¼‰
    if not verify_pipeline_class(request.pipeline_class):
        logger.warning(f"Pipeline class not found: {request.pipeline_class}")
    
    # 4. æ³¨å†ŒPipeline
    success = registry.register_pipeline(
        pipeline_id=request.pipeline_id,
        pipeline_name=request.pipeline_name,
        pipeline_type=request.pipeline_type,
        pipeline_class=request.pipeline_class,
        config_schema=request.config_schema,
        supported_platforms=request.supported_platforms,
        version=request.version,
        metadata=request.metadata
    )
    
    if not success:
        raise HTTPException(500, "Failed to register pipeline")
    
    return {"success": True, "pipeline_id": request.pipeline_id}
```

### 3.2 è·å–Pipelineè¯¦æƒ…æµç¨‹
```python
@router.get("/pipelines/{pipeline_id}")
async def get_pipeline_detail(
    pipeline_id: str,
    current_user = Depends(get_current_user)
):
    """è·å–Pipelineè¯¦ç»†ä¿¡æ¯"""
    registry = get_pipeline_registry()
    db = get_db_manager()
    
    # 1. è·å–PipelineåŸºæœ¬ä¿¡æ¯
    pipeline = registry.get_pipeline(pipeline_id)
    if not pipeline:
        raise HTTPException(404, "Pipeline not found")
    
    # 2. ç»Ÿè®¡ä½¿ç”¨æƒ…å†µ
    usage_count = db.query_one("""
        SELECT COUNT(*) as count
        FROM publish_configs
        WHERE pipeline_id = ? AND is_active = 1
    """, (pipeline_id,))['count']
    
    # 3. ç»„è£…è¿”å›æ•°æ®
    result = pipeline.to_dict()
    result['usage_count'] = usage_count
    
    return result
```

### 3.3 æ›´æ–°Pipelineæµç¨‹
```python
@router.put("/pipelines/{pipeline_id}")
async def update_pipeline(
    pipeline_id: str,
    request: UpdatePipelineRequest,
    current_user = Depends(get_current_user)
):
    """æ›´æ–°Pipelineé…ç½®"""
    registry = get_pipeline_registry()
    
    # 1. æ£€æŸ¥Pipelineæ˜¯å¦å­˜åœ¨
    pipeline = registry.get_pipeline(pipeline_id)
    if not pipeline:
        raise HTTPException(404, "Pipeline not found")
    
    # 2. éªŒè¯æ˜¯å¦æœ‰æ´»è·ƒçš„ä»»åŠ¡
    db = get_db_manager()
    active_tasks = db.query_one("""
        SELECT COUNT(*) as count
        FROM auto_publish_tasks
        WHERE pipeline_id = ? 
          AND pipeline_status IN ('pending', 'running')
    """, (pipeline_id,))['count']
    
    if active_tasks > 0:
        raise HTTPException(400, "Cannot update pipeline with active tasks")
    
    # 3. æ›´æ–°Pipeline
    update_fields = {}
    if request.pipeline_name:
        update_fields['pipeline_name'] = request.pipeline_name
    if request.config_schema:
        validate_json_schema(request.config_schema)
        update_fields['config_schema'] = request.config_schema
    if request.supported_platforms:
        update_fields['supported_platforms'] = request.supported_platforms
    if request.version:
        update_fields['version'] = request.version
    if request.status:
        update_fields['status'] = request.status
    
    success = registry.update_pipeline(pipeline_id, **update_fields)
    
    if not success:
        raise HTTPException(500, "Failed to update pipeline")
    
    return registry.get_pipeline(pipeline_id).to_dict()
```

## 4. æ•°æ®æ¨¡å‹

### 4.1 ä½¿ç”¨ç°æœ‰æ¨¡å‹
```python
# pipeline_registry.pyä¸­çš„PipelineModel
class PipelineModel(Base):
    __tablename__ = 'pipeline_registry'
    
    pipeline_id = Column(String(50), primary_key=True)
    pipeline_name = Column(String(100), nullable=False)
    pipeline_type = Column(String(50), nullable=False)
    pipeline_class = Column(String(200), nullable=False)
    config_schema = Column(JSON)
    supported_platforms = Column(JSON, default=["youtube"])
    version = Column(String(20), default="1.0.0")
    status = Column(String(20), default="active")
    extra_metadata = Column('metadata', JSON)
    created_at = Column(DateTime, default=datetime.now)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)
```

### 4.2 æ‰©å±•æ–¹æ³•
```python
class PipelineRegistry:
    def update_pipeline(self, pipeline_id: str, **kwargs) -> bool:
        """æ›´æ–°Pipelineä¿¡æ¯"""
        with self.get_session() as session:
            pipeline = session.query(PipelineModel).filter_by(
                pipeline_id=pipeline_id
            ).first()
            
            if not pipeline:
                return False
            
            for key, value in kwargs.items():
                if hasattr(pipeline, key):
                    setattr(pipeline, key, value)
            
            pipeline.updated_at = datetime.now()
            session.commit()
            return True
    
    def delete_pipeline(self, pipeline_id: str) -> bool:
        """åˆ é™¤Pipelineï¼ˆè½¯åˆ é™¤ï¼‰"""
        return self.update_pipeline(pipeline_id, status='deleted')
    
    def get_pipeline_configs(self, pipeline_id: str, page: int = 1, 
                           page_size: int = 10) -> dict:
        """è·å–Pipelineå…³è”çš„é…ç½®"""
        with self.get_session() as session:
            query = session.query(PublishConfigModel).filter_by(
                pipeline_id=pipeline_id,
                is_active=True
            )
            
            total = query.count()
            configs = query.offset((page - 1) * page_size).limit(page_size).all()
            
            return {
                'configs': [c.to_dict() for c in configs],
                'total': total,
                'page': page,
                'page_size': page_size
            }
```

## 5. æ•°æ®åº“äº¤äº’

### 5.1 æ ¸å¿ƒSQLæŸ¥è¯¢

```sql
-- è·å–Pipelineåˆ—è¡¨ï¼ˆå«ä½¿ç”¨ç»Ÿè®¡ï¼‰
SELECT 
    pr.*,
    COUNT(DISTINCT pc.config_id) as usage_count,
    COUNT(DISTINCT apt.task_id) as task_count
FROM pipeline_registry pr
LEFT JOIN publish_configs pc ON pr.pipeline_id = pc.pipeline_id AND pc.is_active = 1
LEFT JOIN auto_publish_tasks apt ON pr.pipeline_id = apt.pipeline_id
WHERE pr.status != 'deleted'
GROUP BY pr.pipeline_id
ORDER BY pr.created_at DESC;

-- è·å–Pipelineå…³è”çš„é…ç½®è¯¦æƒ…
SELECT 
    pc.*,
    ag.group_name,
    COUNT(apt.task_id) as task_count,
    MAX(apt.created_at) as last_execution
FROM publish_configs pc
LEFT JOIN account_groups ag ON pc.group_id = ag.group_id
LEFT JOIN auto_publish_tasks apt ON pc.config_id = apt.config_id
WHERE pc.pipeline_id = ?
  AND pc.is_active = 1
GROUP BY pc.config_id
ORDER BY pc.created_at DESC
LIMIT ? OFFSET ?;

-- æ£€æŸ¥Pipelineæ˜¯å¦å¯ä»¥åˆ é™¤
SELECT 
    COUNT(DISTINCT pc.config_id) as active_configs,
    COUNT(DISTINCT apt.task_id) as pending_tasks
FROM pipeline_registry pr
LEFT JOIN publish_configs pc ON pr.pipeline_id = pc.pipeline_id AND pc.is_active = 1
LEFT JOIN auto_publish_tasks apt ON pr.pipeline_id = apt.pipeline_id 
    AND apt.pipeline_status IN ('pending', 'running')
WHERE pr.pipeline_id = ?;
```

## 6. å‰ç«¯å®ç°è¦ç‚¹

### 6.1 å‚æ•°é…ç½®çš„åŠ¨æ€è¡¨å•
```tsx
// å°†å‚æ•°é…ç½®è½¬æ¢ä¸ºè¡¨å•å€¼
const schemaToFormValues = (schema: ConfigSchema) => {
  const parameters = Object.entries(schema.properties).map(([name, param]) => ({
    name,
    type: param.type,
    required: schema.required?.includes(name) || false,
    description: param.description,
    default: param.default,
    minimum: param.minimum,
    maximum: param.maximum,
    enum: param.enum
  }));
  return parameters;
};

// å°†è¡¨å•å€¼è½¬æ¢ä¸ºschema
const formValuesToSchema = (parameters: ParameterConfig[]): ConfigSchema => {
  const properties: any = {};
  const required: string[] = [];
  
  parameters.forEach(param => {
    properties[param.name] = {
      type: param.type,
      description: param.description,
      default: param.default,
      minimum: param.minimum,
      maximum: param.maximum,
      enum: param.enum
    };
    
    if (param.required) {
      required.push(param.name);
    }
  });
  
  return {
    type: 'object',
    properties,
    required: required.length > 0 ? required : undefined
  };
};
```

### 6.2 è·¨Tabè·³è½¬
```tsx
const navigateToConfig = (configId: string) => {
  // è·³è½¬åˆ°å‘å¸ƒé…ç½®Tabï¼Œå¹¶é«˜äº®æŒ‡å®šé…ç½®
  navigate(`/auto-publish?tab=config&highlight=${configId}`);
};
```

### 6.3 æœç´¢å’Œç­›é€‰
```tsx
const [filters, setFilters] = useState({
  search: '',
  type: '',
  status: 'active'
});

const filteredPipelines = pipelines.filter(p => {
  const matchSearch = !filters.search || 
    p.pipeline_id.includes(filters.search) ||
    p.pipeline_name.includes(filters.search);
  
  const matchType = !filters.type || p.pipeline_type === filters.type;
  const matchStatus = !filters.status || p.status === filters.status;
  
  return matchSearch && matchType && matchStatus;
});
```

## 7. æµ‹è¯•è¦ç‚¹

### 7.1 åŠŸèƒ½æµ‹è¯•
- [ ] Pipelineåˆ›å»ºåŠŸèƒ½
- [ ] å‚æ•°åŠ¨æ€æ·»åŠ /åˆ é™¤
- [ ] Pipelineç¼–è¾‘ï¼ˆåŒ…æ‹¬å‚æ•°ä¿®æ”¹ï¼‰
- [ ] Pipelineåˆ é™¤ï¼ˆæ£€æŸ¥å…³è”ï¼‰
- [ ] æœç´¢å’Œç­›é€‰åŠŸèƒ½
- [ ] è·¨Tabè·³è½¬åŠŸèƒ½

### 7.2 éªŒè¯æµ‹è¯•
- [ ] Pipeline IDæ ¼å¼éªŒè¯
- [ ] å‚æ•°ç±»å‹éªŒè¯
- [ ] å¿…å¡«é¡¹éªŒè¯
- [ ] æ•°å€¼èŒƒå›´éªŒè¯

### 7.3 è¾¹ç•Œæµ‹è¯•
- [ ] å¤§é‡å‚æ•°çš„Pipeline
- [ ] å¤æ‚åµŒå¥—çš„å‚æ•°ç»“æ„
- [ ] å¹¶å‘åˆ›å»º/æ›´æ–°

## 8. å®æ–½è¦æ±‚

1. **Pipeline IDå‘½åè§„èŒƒ**ï¼šä½¿ç”¨å°å†™å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿ï¼Œæ ¼å¼ï¼š`^[a-z0-9_]+$`ï¼Œé•¿åº¦3-50å­—ç¬¦
2. **ç‰ˆæœ¬ç®¡ç†**ï¼šPipelineæ›´æ–°æ—¶ç‰ˆæœ¬å·é€’å¢ï¼Œæ ¼å¼ï¼š`v{major}.{minor}.{patch}`
3. **å…¼å®¹æ€§**ï¼šä¿®æ”¹å‚æ•°schemaæ—¶ä¿æŒå‘åå…¼å®¹ï¼Œæ–°å¢å­—æ®µè®¾ç½®é»˜è®¤å€¼
4. **æƒé™æ§åˆ¶**ï¼šåˆ›å»ºå’ŒæŸ¥çœ‹éœ€è¦æ™®é€šæƒé™ï¼Œæ›´æ–°å’Œåˆ é™¤éœ€è¦ç®¡ç†å‘˜æƒé™
5. **æ•°æ®ä¸€è‡´æ€§**ï¼šPipelineåˆ é™¤å‰æ£€æŸ¥æ˜¯å¦æœ‰å…³è”çš„é…ç½®ï¼Œæœ‰åˆ™ç¦æ­¢åˆ é™¤