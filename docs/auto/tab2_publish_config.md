# Tab 2: å‘å¸ƒé…ç½®ç®¡ç†

> å‚è€ƒï¼š[global_context.md](./global_context.md) - å…¨å±€ä¸Šä¸‹æ–‡å’Œè§„èŒƒ

## 1. å‰ç«¯æ–¹æ¡ˆ

### 1.1 ç•Œé¢å¸ƒå±€
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å‘å¸ƒé…ç½®ç®¡ç†                                      [+ åˆ›å»ºé…ç½®]   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ” æœç´¢: [___________] [Pipelineâ–¼] [è´¦å·ç»„â–¼] [çŠ¶æ€â–¼]  [æœç´¢]    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  é…ç½®åˆ—è¡¨ï¼ˆè¡¨æ ¼ï¼‰                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚é…ç½®åç§° â”‚Pipeline  â”‚è´¦å·ç»„    â”‚è°ƒåº¦æ–¹å¼â”‚æ‰§è¡Œæ•°  â”‚æ“ä½œ        â”‚â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”‚
â”‚  â”‚æ¯æ—¥æ•…äº‹â”‚story_v3  â”‚story_grp â”‚æ¯æ—¥20:00â”‚156ä»»åŠ¡â”‚æŸ¥çœ‹ ç¼–è¾‘ åˆ é™¤â”‚â”‚
â”‚  â”‚æµ‹è¯•é…ç½®â”‚meta_gen  â”‚test_grp  â”‚ç›‘æ§è§¦å‘ â”‚45ä»»åŠ¡ â”‚æŸ¥çœ‹ ç¼–è¾‘ åˆ é™¤â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 ç»„ä»¶ç»“æ„
```tsx
// components/AutoPublish/PublishConfigManager.tsx
import React, { useState, useEffect } from 'react';
import {
  Card, Table, Button, Modal, Form, Input, Select, InputNumber,
  Tag, Space, Drawer, Descriptions, Timeline, Badge, message,
  DatePicker, TimePicker, Radio, Tabs, List, Statistic
} from 'antd';
import {
  PlusOutlined, EditOutlined, DeleteOutlined, EyeOutlined,
  CalendarOutlined, RobotOutlined, ClockCircleOutlined
} from '@ant-design/icons';

interface PublishConfig {
  config_id: string;
  config_name: string;
  group_id: string;
  group_name?: string;
  pipeline_id: string;
  pipeline_name?: string;
  pipeline_config?: any;  // Pipelineå‚æ•°é…ç½®
  trigger_type: 'scheduled' | 'monitor';
  trigger_config: TriggerConfig;
  priority: number;
  is_active: boolean;
  created_at: string;
  updated_at: string;
  // ç»Ÿè®¡ä¿¡æ¯
  task_count?: number;
  success_count?: number;
  failed_count?: number;
  last_execution?: string;
  next_execution?: string;
}

interface TriggerConfig {
  // å®šæ—¶è§¦å‘é…ç½®
  schedule?: {
    type: 'daily' | 'weekly' | 'monthly' | 'cron';
    time?: string;  // HH:mm
    weekday?: number;  // 0-6
    day?: number;  // 1-31
    cron?: string;  // cronè¡¨è¾¾å¼
  };
  // ç›‘æ§è§¦å‘é…ç½®
  monitor?: {
    platform: string;
    type: string;
    target: string;
    check_interval: number;
  };
}

interface TaskExecution {
  task_id: string;
  account_id: string;
  account_name?: string;
  pipeline_status: 'pending' | 'running' | 'completed' | 'failed';
  publish_status: 'pending' | 'published' | 'failed';
  created_at: string;
  completed_at?: string;
  duration?: number;
  error_message?: string;
}

interface TaskStats {
  total: number;
  success: number;
  failed: number;
  running: number;
  pending: number;
  avg_duration: number;
  success_rate: number;
}
```

### 1.3 åˆ›å»º/ç¼–è¾‘é…ç½®è¡¨å•

#### 1.3.1 åŸºæœ¬ä¿¡æ¯
```tsx
const ConfigForm: React.FC = () => {
  const [triggerType, setTriggerType] = useState<'scheduled' | 'monitor'>('scheduled');
  const [pipelineSchema, setPipelineSchema] = useState<any>(null);
  
  return (
    <Form form={form} layout="vertical">
      <Form.Item name="config_name" label="é…ç½®åç§°" rules={[{ required: true }]}>
        <Input placeholder="ä¾‹å¦‚: æ¯æ—¥æ•…äº‹å‘å¸ƒ" />
      </Form.Item>
      
      <Row gutter={16}>
        <Col span={12}>
          <Form.Item name="pipeline_id" label="é€‰æ‹©Pipeline" rules={[{ required: true }]}>
            <Select onChange={handlePipelineChange} placeholder="é€‰æ‹©Pipeline">
              {pipelines.map(p => (
                <Option key={p.pipeline_id} value={p.pipeline_id}>
                  {p.pipeline_name}
                </Option>
              ))}
            </Select>
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="group_id" label="é€‰æ‹©è´¦å·ç»„" rules={[{ required: true }]}>
            <Select placeholder="é€‰æ‹©è´¦å·ç»„">
              {groups.map(g => (
                <Option key={g.group_id} value={g.group_id}>
                  {g.group_name} ({g.member_count}ä¸ªè´¦å·)
                </Option>
              ))}
            </Select>
          </Form.Item>
        </Col>
      </Row>
      
      <Form.Item name="priority" label="ä¼˜å…ˆçº§" 
        tooltip="æ•°å€¼è¶Šå¤§ä¼˜å…ˆçº§è¶Šé«˜ï¼ŒèŒƒå›´0-100">
        <Slider min={0} max={100} defaultValue={50} 
          marks={{ 0: 'ä½', 50: 'ä¸­', 100: 'é«˜' }} />
      </Form.Item>
      
      {/* Pipelineå‚æ•°é…ç½®ï¼ˆæ ¹æ®é€‰æ‹©çš„PipelineåŠ¨æ€ç”Ÿæˆï¼‰ */}
      {pipelineSchema && (
        <Card title="Pipelineå‚æ•°é…ç½®" size="small">
          {renderPipelineParams(pipelineSchema)}
        </Card>
      )}
      
      {/* è§¦å‘æ–¹å¼é…ç½® */}
      <Form.Item label="è§¦å‘æ–¹å¼">
        <Radio.Group value={triggerType} onChange={e => setTriggerType(e.target.value)}>
          <Radio.Button value="scheduled">
            <CalendarOutlined /> å®šæ—¶è§¦å‘
          </Radio.Button>
          <Radio.Button value="monitor">
            <RobotOutlined /> ç›‘æ§è§¦å‘
          </Radio.Button>
        </Radio.Group>
      </Form.Item>
      
      {triggerType === 'scheduled' ? renderScheduleConfig() : renderMonitorConfig()}
    </Form>
  );
};
```

#### 1.3.2 å®šæ—¶è§¦å‘é…ç½®
```tsx
const renderScheduleConfig = () => (
  <Card title="å®šæ—¶è§¦å‘é…ç½®" size="small">
    <Form.Item name={['trigger_config', 'schedule', 'type']} label="è°ƒåº¦ç±»å‹">
      <Radio.Group>
        <Radio value="daily">æ¯æ—¥</Radio>
        <Radio value="weekly">æ¯å‘¨</Radio>
        <Radio value="monthly">æ¯æœˆ</Radio>
        <Radio value="cron">Cronè¡¨è¾¾å¼</Radio>
      </Radio.Group>
    </Form.Item>
    
    <Form.Item 
      noStyle
      shouldUpdate={(prev, cur) => 
        prev.trigger_config?.schedule?.type !== cur.trigger_config?.schedule?.type
      }>
      {({ getFieldValue }) => {
        const scheduleType = getFieldValue(['trigger_config', 'schedule', 'type']);
        
        switch (scheduleType) {
          case 'daily':
            return (
              <Form.Item name={['trigger_config', 'schedule', 'time']} label="æ‰§è¡Œæ—¶é—´">
                <TimePicker format="HH:mm" />
              </Form.Item>
            );
          
          case 'weekly':
            return (
              <>
                <Form.Item name={['trigger_config', 'schedule', 'weekday']} label="æ˜ŸæœŸ">
                  <Select>
                    <Option value={0}>å‘¨æ—¥</Option>
                    <Option value={1}>å‘¨ä¸€</Option>
                    <Option value={2}>å‘¨äºŒ</Option>
                    <Option value={3}>å‘¨ä¸‰</Option>
                    <Option value={4}>å‘¨å››</Option>
                    <Option value={5}>å‘¨äº”</Option>
                    <Option value={6}>å‘¨å…­</Option>
                  </Select>
                </Form.Item>
                <Form.Item name={['trigger_config', 'schedule', 'time']} label="æ‰§è¡Œæ—¶é—´">
                  <TimePicker format="HH:mm" />
                </Form.Item>
              </>
            );
          
          case 'cron':
            return (
              <Form.Item name={['trigger_config', 'schedule', 'cron']} label="Cronè¡¨è¾¾å¼"
                rules={[{ pattern: /^[\d\s\*\/\-\,]+$/ }]}>
                <Input placeholder="ä¾‹å¦‚: 0 20 * * *" />
              </Form.Item>
            );
          
          default:
            return null;
        }
      }}
    </Form.Item>
  </Card>
);
```

### 1.4 é…ç½®è¯¦æƒ…æŠ½å±‰
```tsx
const ConfigDetail: React.FC<{ config: PublishConfig }> = ({ config }) => {
  const [tasks, setTasks] = useState<TaskExecution[]>([]);
  const [stats, setStats] = useState<TaskStats | null>(null);
  const [loading, setLoading] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  
  useEffect(() => {
    loadTaskExecutions();
    loadTaskStats();
  }, [config.config_id]);
  
  return (
    <Drawer title="é…ç½®è¯¦æƒ…" width={900} visible={visible} onClose={onClose}>
      <Descriptions title="åŸºæœ¬ä¿¡æ¯" bordered column={2}>
        <Descriptions.Item label="é…ç½®åç§°">{config.config_name}</Descriptions.Item>
        <Descriptions.Item label="çŠ¶æ€">
          <Badge status={config.is_active ? 'success' : 'default'} 
            text={config.is_active ? 'å¯ç”¨' : 'åœç”¨'} />
        </Descriptions.Item>
        <Descriptions.Item label="Pipeline">{config.pipeline_name}</Descriptions.Item>
        <Descriptions.Item label="è´¦å·ç»„">{config.group_name}</Descriptions.Item>
        <Descriptions.Item label="è§¦å‘æ–¹å¼">
          {config.trigger_type === 'scheduled' ? 'å®šæ—¶è§¦å‘' : 'ç›‘æ§è§¦å‘'}
        </Descriptions.Item>
        <Descriptions.Item label="ä¼˜å…ˆçº§">
          <Progress percent={config.priority} steps={5} size="small" />
        </Descriptions.Item>
        <Descriptions.Item label="åˆ›å»ºæ—¶é—´">{config.created_at}</Descriptions.Item>
        <Descriptions.Item label="æœ€è¿‘æ‰§è¡Œ">{config.last_execution || '-'}</Descriptions.Item>
      </Descriptions>
      
      <Divider />
      
      {/* æ‰§è¡Œç»Ÿè®¡ */}
      {stats && (
        <Card title="æ‰§è¡Œç»Ÿè®¡" size="small">
          <Row gutter={16}>
            <Col span={6}>
              <Statistic title="æ€»æ‰§è¡Œæ¬¡æ•°" value={stats.total} />
            </Col>
            <Col span={6}>
              <Statistic title="æˆåŠŸç‡" value={stats.success_rate} suffix="%" 
                valueStyle={{ color: stats.success_rate > 90 ? '#3f8600' : '#cf1322' }} />
            </Col>
            <Col span={6}>
              <Statistic title="å¹³å‡è€—æ—¶" value={stats.avg_duration} suffix="ç§’" />
            </Col>
            <Col span={6}>
              <Statistic title="å¤±è´¥æ¬¡æ•°" value={stats.failed} 
                valueStyle={{ color: '#cf1322' }} />
            </Col>
          </Row>
        </Card>
      )}
      
      <Divider />
      
      {/* æ‰§è¡Œå†å² */}
      <Card title={`æ‰§è¡Œå†å² (${stats?.total || 0}æ¡)`} size="small">
        <Table
          dataSource={tasks}
          loading={loading}
          rowKey="task_id"
          size="small"
          pagination={{
            current: currentPage,
            pageSize: 10,
            total: stats?.total || 0,
            onChange: (page) => {
              setCurrentPage(page);
              loadTaskExecutions(page);
            }
          }}
          columns={[
            {
              title: 'ä»»åŠ¡ID',
              dataIndex: 'task_id',
              width: 120,
              render: (id: string) => (
                <Button type="link" size="small" 
                  onClick={() => navigateToTask(id)}>
                  {id.substring(0, 8)}...
                </Button>
              )
            },
            {
              title: 'è´¦å·',
              dataIndex: 'account_name',
              width: 120
            },
            {
              title: 'PipelineçŠ¶æ€',
              dataIndex: 'pipeline_status',
              width: 100,
              render: (status: string) => {
                const color = {
                  'completed': 'green',
                  'running': 'blue',
                  'failed': 'red',
                  'pending': 'default'
                }[status];
                return <Tag color={color}>{status}</Tag>;
              }
            },
            {
              title: 'å‘å¸ƒçŠ¶æ€',
              dataIndex: 'publish_status',
              width: 100,
              render: (status: string) => {
                const color = {
                  'published': 'green',
                  'failed': 'red',
                  'pending': 'default'
                }[status];
                return <Tag color={color}>{status}</Tag>;
              }
            },
            {
              title: 'æ‰§è¡Œæ—¶é—´',
              dataIndex: 'created_at',
              width: 150,
              render: (time: string) => moment(time).format('MM-DD HH:mm')
            },
            {
              title: 'è€—æ—¶',
              dataIndex: 'duration',
              width: 80,
              render: (d: number) => d ? `${d}ç§’` : '-'
            },
            {
              title: 'æ“ä½œ',
              width: 100,
              render: (_: any, record: TaskExecution) => (
                <Space>
                  <Button type="link" size="small" 
                    onClick={() => navigateToTask(record.task_id)}>
                    æŸ¥çœ‹
                  </Button>
                  {record.pipeline_status === 'failed' && (
                    <Button type="link" size="small" danger
                      onClick={() => retryTask(record.task_id)}>
                      é‡è¯•
                    </Button>
                  )}
                </Space>
              )
            }
          ]}
        />
        
        {/* æ‰§è¡Œæ—¶é—´çº¿ */}
        <Timeline style={{ marginTop: 16 }}>
          {tasks.slice(0, 5).map(task => (
            <Timeline.Item 
              key={task.task_id}
              color={task.pipeline_status === 'completed' ? 'green' : 'red'}>
              <p>{task.account_name} - {moment(task.created_at).format('MM-DD HH:mm')}</p>
              <p>{task.pipeline_status === 'completed' ? 'âœ… æˆåŠŸ' : `âŒ å¤±è´¥: ${task.error_message}`}</p>
            </Timeline.Item>
          ))}
        </Timeline>
      </Card>
    </Drawer>
  );
};
```

## 2. éœ€è¦çš„æ¥å£

### 2.1 å¤ç”¨ç°æœ‰æ¥å£
```http
GET /api/auto-publish/publish-configs
POST /api/auto-publish/publish-configs
```

### 2.2 æ–°å¢æ¥å£

#### 2.2.1 è·å–é…ç½®çš„æ‰§è¡Œå†å²
```http
GET /api/auto-publish/configs/{config_id}/tasks

Queryå‚æ•°:
  - page: number (é»˜è®¤1)
  - page_size: number (é»˜è®¤10)
  - status: string (å¯é€‰ï¼Œç­›é€‰çŠ¶æ€)
  - start_date: string (å¯é€‰ï¼Œå¼€å§‹æ—¥æœŸ)
  - end_date: string (å¯é€‰ï¼Œç»“æŸæ—¥æœŸ)

å“åº”:
{
  "tasks": [
    {
      "task_id": "task_20241225_001",
      "account_id": "yt_001",
      "account_name": "å°è¯´é¢‘é“1",
      "pipeline_status": "completed",
      "publish_status": "published",
      "created_at": "2024-12-25T20:00:00Z",
      "completed_at": "2024-12-25T20:05:00Z",
      "duration": 300,
      "error_message": null
    }
  ],
  "total": 156,
  "page": 1,
  "page_size": 10
}
```

#### 2.2.2 è·å–é…ç½®æ‰§è¡Œç»Ÿè®¡
```http
GET /api/auto-publish/configs/{config_id}/stats

å“åº”:
{
  "total": 156,
  "success": 145,
  "failed": 8,
  "running": 1,
  "pending": 2,
  "avg_duration": 285.5,
  "success_rate": 92.9,
  "last_execution": "2024-12-25T20:00:00Z",
  "next_execution": "2024-12-26T20:00:00Z"
}
```

#### 2.2.3 æ›´æ–°é…ç½®
```http
PUT /api/auto-publish/configs/{config_id}

è¯·æ±‚ä½“: åŒåˆ›å»ºï¼Œä½†config_idä¸å¯ä¿®æ”¹

å“åº”: æ›´æ–°åçš„é…ç½®å¯¹è±¡
```

#### 2.2.4 åˆ é™¤é…ç½®
```http
DELETE /api/auto-publish/configs/{config_id}

å“åº”:
{
  "success": true,
  "message": "Config deleted successfully"
}
```

#### 2.2.5 å¯ç”¨/ç¦ç”¨é…ç½®
```http
POST /api/auto-publish/configs/{config_id}/toggle

è¯·æ±‚ä½“:
{
  "is_active": true
}

å“åº”:
{
  "success": true,
  "is_active": true
}
```

## 3. åç«¯æ‰§è¡Œæµç¨‹

### 3.1 åˆ›å»ºé…ç½®æµç¨‹
```python
@router.post("/publish-configs")
async def create_publish_config(
    request: CreatePublishConfigRequest,
    current_user = Depends(get_current_user)
):
    """åˆ›å»ºå‘å¸ƒé…ç½®"""
    db = get_db_manager()
    executor = get_account_driven_executor()
    
    # 1. éªŒè¯Pipelineå­˜åœ¨
    pipeline = get_pipeline_registry().get_pipeline(request.pipeline_id)
    if not pipeline:
        raise HTTPException(404, "Pipeline not found")
    
    # 2. éªŒè¯è´¦å·ç»„å­˜åœ¨
    group = db.query_one(
        "SELECT * FROM account_groups WHERE group_id = ?",
        (request.group_id,)
    )
    if not group:
        raise HTTPException(404, "Account group not found")
    
    # 3. éªŒè¯Pipelineå‚æ•°
    if request.pipeline_config:
        validate_pipeline_config(pipeline.config_schema, request.pipeline_config)
    
    # 4. åˆ›å»ºé…ç½®
    config_id = f"config_{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    config = PublishConfigModel(
        config_id=config_id,
        config_name=request.config_name,
        group_id=request.group_id,
        pipeline_id=request.pipeline_id,
        pipeline_config=request.pipeline_config,
        trigger_type=request.trigger_type,
        trigger_config=request.trigger_config,
        priority=request.priority,
        is_active=True
    )
    
    db.session.add(config)
    db.session.commit()
    
    # 5. æ³¨å†Œåˆ°æ‰§è¡Œå™¨
    if request.trigger_type == 'scheduled':
        executor.register_scheduled_config(config)
    
    return config.to_dict()
```

### 3.2 è·å–æ‰§è¡Œå†å²æµç¨‹
```python
@router.get("/configs/{config_id}/tasks")
async def get_config_tasks(
    config_id: str,
    page: int = Query(1, ge=1),
    page_size: int = Query(10, ge=1, le=100),
    status: Optional[str] = None,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    current_user = Depends(get_current_user)
):
    """è·å–é…ç½®çš„æ‰§è¡Œå†å²"""
    db = get_db_manager()
    
    # æ„å»ºæŸ¥è¯¢æ¡ä»¶
    conditions = ["config_id = ?"]
    params = [config_id]
    
    if status:
        conditions.append("pipeline_status = ?")
        params.append(status)
    
    if start_date:
        conditions.append("created_at >= ?")
        params.append(start_date)
    
    if end_date:
        conditions.append("created_at <= ?")
        params.append(end_date)
    
    where_clause = " AND ".join(conditions)
    
    # æŸ¥è¯¢æ€»æ•°
    total = db.query_one(
        f"SELECT COUNT(*) as count FROM auto_publish_tasks WHERE {where_clause}",
        params
    )['count']
    
    # æŸ¥è¯¢ä»»åŠ¡åˆ—è¡¨
    offset = (page - 1) * page_size
    tasks = db.query(f"""
        SELECT 
            apt.*,
            a.account_name
        FROM auto_publish_tasks apt
        LEFT JOIN accounts a ON apt.account_id = a.account_id
        WHERE {where_clause}
        ORDER BY apt.created_at DESC
        LIMIT ? OFFSET ?
    """, params + [page_size, offset])
    
    return {
        "tasks": tasks,
        "total": total,
        "page": page,
        "page_size": page_size
    }
```

### 3.3 è·å–æ‰§è¡Œç»Ÿè®¡æµç¨‹
```python
@router.get("/configs/{config_id}/stats")
async def get_config_stats(
    config_id: str,
    current_user = Depends(get_current_user)
):
    """è·å–é…ç½®æ‰§è¡Œç»Ÿè®¡"""
    db = get_db_manager()
    
    stats = db.query_one("""
        SELECT 
            COUNT(*) as total,
            SUM(CASE WHEN pipeline_status = 'completed' THEN 1 ELSE 0 END) as success,
            SUM(CASE WHEN pipeline_status = 'failed' THEN 1 ELSE 0 END) as failed,
            SUM(CASE WHEN pipeline_status = 'running' THEN 1 ELSE 0 END) as running,
            SUM(CASE WHEN pipeline_status = 'pending' THEN 1 ELSE 0 END) as pending,
            AVG(CASE WHEN completed_at IS NOT NULL 
                THEN TIMESTAMPDIFF(SECOND, started_at, completed_at) 
                ELSE NULL END) as avg_duration,
            MAX(created_at) as last_execution
        FROM auto_publish_tasks
        WHERE config_id = ?
    """, (config_id,))
    
    # è®¡ç®—æˆåŠŸç‡
    if stats['total'] > 0:
        stats['success_rate'] = round(stats['success'] / stats['total'] * 100, 1)
    else:
        stats['success_rate'] = 0
    
    # è·å–ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´ï¼ˆå¦‚æœæ˜¯å®šæ—¶ä»»åŠ¡ï¼‰
    config = db.query_one(
        "SELECT trigger_type, trigger_config FROM publish_configs WHERE config_id = ?",
        (config_id,)
    )
    
    if config and config['trigger_type'] == 'scheduled':
        stats['next_execution'] = calculate_next_execution(config['trigger_config'])
    
    return stats
```

## 4. æ•°æ®æ¨¡å‹

ä½¿ç”¨ç°æœ‰æ¨¡å‹ï¼š
- `publish_configs` - å‘å¸ƒé…ç½®è¡¨
- `auto_publish_tasks` - ä»»åŠ¡æ‰§è¡Œè¡¨
- `account_groups` - è´¦å·ç»„è¡¨
- `pipeline_registry` - Pipelineæ³¨å†Œè¡¨

## 5. æ•°æ®åº“äº¤äº’

### 5.1 æ ¸å¿ƒSQLæŸ¥è¯¢

```sql
-- è·å–é…ç½®åˆ—è¡¨ï¼ˆå«ç»Ÿè®¡ä¿¡æ¯ï¼‰
SELECT 
    pc.*,
    ag.group_name,
    pr.pipeline_name,
    COUNT(DISTINCT apt.task_id) as task_count,
    SUM(CASE WHEN apt.pipeline_status = 'completed' THEN 1 ELSE 0 END) as success_count,
    SUM(CASE WHEN apt.pipeline_status = 'failed' THEN 1 ELSE 0 END) as failed_count,
    MAX(apt.created_at) as last_execution
FROM publish_configs pc
LEFT JOIN account_groups ag ON pc.group_id = ag.group_id
LEFT JOIN pipeline_registry pr ON pc.pipeline_id = pr.pipeline_id
LEFT JOIN auto_publish_tasks apt ON pc.config_id = apt.config_id
WHERE pc.is_active = 1
GROUP BY pc.config_id
ORDER BY pc.created_at DESC;

-- è·å–é…ç½®çš„æ‰§è¡Œå†å²
SELECT 
    apt.*,
    a.account_name,
    TIMESTAMPDIFF(SECOND, apt.started_at, apt.completed_at) as duration
FROM auto_publish_tasks apt
LEFT JOIN accounts a ON apt.account_id = a.account_id
WHERE apt.config_id = ?
ORDER BY apt.created_at DESC
LIMIT ? OFFSET ?;

-- è·å–é…ç½®çš„è´¦å·ç»„æ‰§è¡Œæƒ…å†µ
SELECT 
    a.account_id,
    a.account_name,
    COUNT(apt.task_id) as total_tasks,
    SUM(CASE WHEN apt.pipeline_status = 'completed' THEN 1 ELSE 0 END) as success_tasks,
    AVG(TIMESTAMPDIFF(SECOND, apt.started_at, apt.completed_at)) as avg_duration
FROM accounts a
JOIN account_group_members agm ON a.account_id = agm.account_id
LEFT JOIN auto_publish_tasks apt ON a.account_id = apt.account_id 
    AND apt.config_id = ?
WHERE agm.group_id = ?
GROUP BY a.account_id;
```

## 6. å‰ç«¯å®ç°è¦ç‚¹

### 6.1 Pipelineå‚æ•°åŠ¨æ€è¡¨å•
```tsx
const renderPipelineParams = (schema: any) => {
  if (!schema || !schema.properties) return null;
  
  return Object.entries(schema.properties).map(([key, param]: [string, any]) => {
    const isRequired = schema.required?.includes(key);
    
    switch (param.type) {
      case 'string':
        if (param.enum) {
          return (
            <Form.Item 
              key={key}
              name={['pipeline_config', key]} 
              label={key}
              rules={[{ required: isRequired }]}
              tooltip={param.description}>
              <Select>
                {param.enum.map((v: string) => (
                  <Option key={v} value={v}>{v}</Option>
                ))}
              </Select>
            </Form.Item>
          );
        }
        return (
          <Form.Item 
            key={key}
            name={['pipeline_config', key]} 
            label={key}
            rules={[{ required: isRequired }]}
            tooltip={param.description}>
            <Input placeholder={param.description} />
          </Form.Item>
        );
      
      case 'integer':
      case 'number':
        return (
          <Form.Item 
            key={key}
            name={['pipeline_config', key]} 
            label={key}
            rules={[{ required: isRequired }]}
            tooltip={param.description}>
            <InputNumber 
              min={param.minimum} 
              max={param.maximum}
              placeholder={param.description} />
          </Form.Item>
        );
      
      case 'boolean':
        return (
          <Form.Item 
            key={key}
            name={['pipeline_config', key]} 
            label={key}
            valuePropName="checked"
            tooltip={param.description}>
            <Switch />
          </Form.Item>
        );
      
      default:
        return null;
    }
  });
};
```

### 6.2 è·³è½¬åˆ°ä»»åŠ¡è¯¦æƒ…
```tsx
const navigateToTask = (taskId: string) => {
  navigate(`/auto-publish?tab=task&task=${taskId}`);
};
```

### 6.3 å®šæ—¶ä»»åŠ¡é¢„è§ˆ
```tsx
const previewSchedule = (triggerConfig: any) => {
  // è®¡ç®—æ¥ä¸‹æ¥5æ¬¡æ‰§è¡Œæ—¶é—´
  const nextExecutions = calculateNextExecutions(triggerConfig, 5);
  
  return (
    <Timeline>
      {nextExecutions.map((time, index) => (
        <Timeline.Item key={index}>
          {moment(time).format('YYYY-MM-DD HH:mm:ss')}
        </Timeline.Item>
      ))}
    </Timeline>
  );
};
```

## 7. æµ‹è¯•è¦ç‚¹

### 7.1 åŠŸèƒ½æµ‹è¯•
- [ ] é…ç½®åˆ›å»ºï¼ˆå„ç§è§¦å‘æ–¹å¼ï¼‰
- [ ] Pipelineå‚æ•°é…ç½®éªŒè¯
- [ ] é…ç½®ç¼–è¾‘å’Œæ›´æ–°
- [ ] é…ç½®å¯ç”¨/ç¦ç”¨
- [ ] æ‰§è¡Œå†å²æŸ¥çœ‹
- [ ] ä»»åŠ¡é‡è¯•åŠŸèƒ½

### 7.2 è¾¹ç•Œæµ‹è¯•
- [ ] å¤§é‡æ‰§è¡Œå†å²çš„åˆ†é¡µ
- [ ] å¤æ‚Pipelineå‚æ•°é…ç½®
- [ ] å¹¶å‘é…ç½®åˆ›å»º

## 8. æ³¨æ„äº‹é¡¹

1. **è§¦å‘æ—¶é—´è®¡ç®—**ï¼šå®šæ—¶ä»»åŠ¡éœ€è¦è€ƒè™‘æ—¶åŒºé—®é¢˜
2. **å‚æ•°éªŒè¯**ï¼šPipelineå‚æ•°éœ€è¦ä¸¥æ ¼éªŒè¯
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šæ‰§è¡Œå†å²æŸ¥è¯¢éœ€è¦åˆç†ç´¢å¼•
4. **çŠ¶æ€åŒæ­¥**ï¼šé…ç½®çŠ¶æ€å˜æ›´éœ€è¦é€šçŸ¥æ‰§è¡Œå™¨